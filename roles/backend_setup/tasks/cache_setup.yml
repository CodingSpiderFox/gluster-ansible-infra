---
# This playbook sets up lvm cache. Primarily written for the hyperconverged
# setup.

# Create PV for setting up cache with dataalignment of 256K for SSDs.
# Extend the existing volume group with the SSD (assuming SSD is used for
# caching)

- name: Extend volume group
  lvg:
     state: present
     vg: "{{ item.vgname }}"
     pvs: "{{ item.cachedisk }}"
     pv_options: "--dataalignment 256K"
  with_items: "{{ gluster_infra_cache_vars }}"

- name: Check if cachepool exists
  shell: "lvs --options 'lv_attr' -a --noheadings {{item.vgname}}/{{item.cachelvname}}| sed 's/^ *//;s/$//'"    
  register: checkpool_attrs
  with_items: "{{ gluster_infra_cache_vars }}"
  tags: debug

- name: Check if cachepool-metadata exists
  shell: "lvs --options 'lv_attr' -a --noheadings {{item.vgname}}/{{item.cachelvname}}_cmeta| sed 's/^ *//;s/$//'"    
  register: checkpoolmeta_attrs
  with_items: "{{ gluster_infra_cache_vars }}"  
  tags: debug

- name: Check if logical data volume
  shell: lvs -a --options 'lv_attr' --noheading {{item.vgname}}/{{item.cachethinpoolname}} | sed 's/^ *//;s/$//'
  register: datapool_attrs
  with_items: "{{ gluster_infra_cache_vars }}"  
  tags: debug

- name: Check if logical volume exists and is backed by the cache pool
#   shell: >
#       lvs -a --options 'data_lv' --noheading {{item.vgname}}/{{item.cachethinpoolname}} 2>/dev/null | awk '{ gsub(/^\[/,"",$1);gsub(/\]$/,"",$1);if(length($1)>0){ print "{{item.vgname}}/"$1}}' |
#       xargs -r lvs -a --noheadings --options 'pool_lv'| sed 's/^ *//;s/$//'
  shell: >
      lvs -a --options 'data_lv,pool_lv' --separator "|" --noheadings  {{item.vgname}}/{{item.cachethinpoolname}} 2>/dev/null| 
         awk -F '|'   '{ gsub(/^\s*\[/,"",$1);gsub(/\]\|?$/,"",$1);if(length($2)>0){ print "echo "$2}else if(length($1)>0){ print "lvs -a --noheadings --options 'pool_lv' {{item.vgname}}/"$1}}'|
         bash|sed 's/^ *//;s/$//'
  register: datapoolcache_attrs
  with_items: "{{ gluster_infra_cache_vars }}"  
  tags: debug  

- debug: 
   var: checkpool_attrs
   verbosity: 1
  tags: debug

- debug: 
   var: item.1.stdout.find(item.0.cachelvname)
   verbosity: 1
  loop: "{{ gluster_infra_cache_vars|zip(datapoolcache_attrs.results)|list }}"
  tags: debug

- debug: 
   msg: "exec convert {{ item.0.cachelvname }} - {{ item.1.stdout }} - {{ item.1.stdout.find(item.0.cachelvname) }} = {{ index }}= {{datapool_attrs.results[index]}}"
   verbosity: 0
  loop: "{{ gluster_infra_cache_vars|zip(datapoolcache_attrs.results)|list }}"
  loop_control:
   index_var: index
  #when: item.1.stdout.find(item.0.cachelvname) == -1
  tags: debug

- name: Change attributes of LV
  lvol:
     state: present
     vg: "{{ item.vgname }}"
     thinpool: "{{ item.cachethinpoolname }}"
     opts: " --zero n "
  with_items: "{{ gluster_infra_cache_vars }}"


- name: Create LV for cache
  lvol:
     state: present
     vg: "{{ item.0.vgname }}"
     lv: "{{ item.0.cachelvname }}"
     size: "{{ item.0.cachelvsize }}"
  #with_items: "{{ gluster_infra_cache_vars }}"
  #Operation not permitted on hidden LV ans_vg/cache-ans_thinpool2.
  #Sorry, no shrinking of cache-ans_thinpool3 without force=yes.
  when: item.1.stdout.find('C') != 0
  loop: "{{ gluster_infra_cache_vars | zip(checkpool_attrs.results) | list }}"
  tags: debug

- name: Create metadata LV for cache
  lvol:
     state: present
     vg: "{{ item.0.vgname }}"
     lv: "{{ item.0.cachemetalvname }}"
     size: "{{ item.0.cachemetalvsize }}"
  #with_items: "{{ gluster_infra_cache_vars }}"
  loop: "{{ gluster_infra_cache_vars | zip(checkpoolmeta_attrs.results) | list }}"
  when: item.0.cachemetalvname is defined and item.1.stdout.find('e') != 0
  tags: debug

#Command on LV ans_vg/cache-ans_thinpool2 does not accept LV type cachepool
- name: Convert logical volume to a cache pool LV
  command: >
     lvconvert -y --type cache-pool 
        {% if item.0.cachemetalvname is defined %} 
         --poolmetadata {{ item.0.cachemetalvname }} 
        {% endif %}
        --poolmetadataspare n
        --cachemode {{item.0.cachemode | default('writethrough')}}
        "/dev/{{item.0.vgname}}/{{item.0.cachelvname}}"
  loop: "{{ gluster_infra_cache_vars | zip(checkpool_attrs.results) | list }}"
  when: item.1.stdout.find('C') != 0
  tags: debug

# It is valid not to have cachemetalvname! Writing a separate task not to
# complicate things.
# - name: Convert logical volume to a cache pool LV without cachemetalvname
#   command: >
#      lvconvert -y --type cache-pool
#         --poolmetadataspare n
#         --cachemode {{item.cachemode | default('writethrough')}}
#         "/dev/{{item.vgname}}/{{item.cachelvname}}"
#   loop: "{{ gluster_infra_cache_vars }}"
#   when: item.cachemetalvname is not defined

# Run lvs -a -o +devices to see the cache settings
- name: Convert an existing logical volume to a cache LV
  command: >
     lvconvert -y --type cache --cachepool "/dev/{{item.0.vgname}}/{{item.0.cachelvname}}"
     "/dev/{{item.0.vgname}}/{{item.0.cachethinpoolname}}"
#   with_items: "{{ gluster_infra_cache_vars }}"
  loop: "{{ gluster_infra_cache_vars | zip(datapoolcache_attrs.results) | list }}"
  loop_control:
   index_var: index
  #check if the LV exists and is not yet converted to a cache volume 
  when: (datapool_attrs.results[index].stdout is not defined or datapool_attrs.results[index].stdout|length>0) and item.1.stdout.find(item.0.cachelvname) == -1
  tags: debug
